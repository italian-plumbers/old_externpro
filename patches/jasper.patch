diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..92cbdd1
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,7 @@
+cmake_minimum_required(VERSION 3.20)
+project(jasper)
+include(GNUInstallDirs)
+include(flags OPTIONAL)
+include(configure.cmake)
+add_subdirectory(src/libjasper)
+add_subdirectory(src/appl)
diff --git a/configure.cmake b/configure.cmake
new file mode 100644
index 0000000..170dbd9
--- /dev/null
+++ b/configure.cmake
@@ -0,0 +1,289 @@
+include(CheckCSourceCompiles)
+include(CheckFunctionExists)
+include(CheckIncludeFile)
+include(CheckLibraryExists)
+include(CheckSymbolExists)
+include(CheckTypeSize)
+########################################
+function(set_define var)
+  if(${ARGC} GREATER 1 AND ${var})
+    set(DEFINE_${var} cmakedefine01 PARENT_SCOPE)
+  else()
+    set(DEFINE_${var} cmakedefine PARENT_SCOPE)
+  endif()
+  if(${var})
+    set(JAS_TEST_DEFINES "${JAS_TEST_DEFINES} -D${var}" PARENT_SCOPE)
+    set(CMAKE_REQUIRED_DEFINITIONS ${JAS_TEST_DEFINES} PARENT_SCOPE)
+  endif(${var})
+endfunction()
+##########
+macro(check_include_file_concat incfile var)
+  check_include_file("${incfile}" ${var})
+  set_define(${var} 1)
+  if(${var})
+    set(JAS_INCLUDES ${JAS_INCLUDES} ${incfile})
+  endif(${var})
+endmacro()
+##########
+macro(check_exists_define01 func var)
+  if(UNIX)
+    check_function_exists("${func}" ${var})
+  else()
+    check_symbol_exists("${func}" "${JAS_INCLUDES}" ${var})
+  endif()
+  set_define(${var} 1)
+endmacro()
+##########
+macro(check_library_exists_concat lib symbol var)
+  check_library_exists("${lib};${JAS_SYSTEM_LIBS}" ${symbol} "${CMAKE_LIBRARY_PATH}" ${var})
+  set_define(${var} 1)
+  if(${var})
+    set(JAS_SYSTEM_LIBS ${lib} ${JAS_SYSTEM_LIBS})
+    set(CMAKE_REQUIRED_LIBRARIES ${JAS_SYSTEM_LIBS})
+  endif(${var})
+endmacro()
+########################################
+check_include_file_concat(windows.h HAVE_WINDOWS_H)
+check_include_file_concat(dlfcn.h HAVE_DLFCN_H)
+check_include_file_concat(fcntl.h HAVE_FCNTL_H)
+check_include_file_concat(inttypes.h HAVE_INTTYPES_H)
+check_include_file_concat(io.h HAVE_IO_H)
+check_include_file_concat(limits.h HAVE_LIMITS_H)
+check_include_file_concat(memory.h HAVE_MEMORY_H)
+check_include_file_concat(stdbool.h HAVE_STDBOOL_H)
+check_include_file_concat(stddef.h HAVE_STDDEF_H)
+check_include_file_concat(stdint.h HAVE_STDINT_H)
+check_include_file_concat(stdlib.h HAVE_STDLIB_H)
+check_include_file_concat(strings.h HAVE_STRINGS_H)
+check_include_file_concat(string.h HAVE_STRING_H)
+check_include_file_concat(sys/stat.h HAVE_SYS_STAT_H)
+check_include_file_concat(sys/time.h HAVE_SYS_TIME_H)
+check_include_file_concat(sys/types.h HAVE_SYS_TYPES_H)
+check_include_file_concat(unistd.h HAVE_UNISTD_H)
+##########
+check_library_exists_concat(m log HAVE_LIBM)
+##########
+check_exists_define01(getrusage HAVE_GETRUSAGE)
+check_exists_define01(gettimeofday HAVE_GETTIMEOFDAY)
+check_exists_define01(vprintf HAVE_VPRINTF) #TODO: not used in code?
+########################################
+set(CMAKE_EXTRA_INCLUDE_FILES sys/types.h)
+check_type_size(longlong SIZEOF_LONGLONG) # sets HAVE_SIZEOF_LONGLONG
+check_type_size(size_t SIZEOF_SIZE_T) # sets HAVE_SIZEOF_SIZE_T
+check_type_size(ssize_t SIZEOF_SSIZE_T) # sets HAVE_SIZEOF_SSIZE_T
+check_type_size(uchar SIZEOF_UCHAR) # sets HAVE_SIZEOF_UCHAR
+check_type_size(uint SIZEOF_UINT) # sets HAVE_SIZEOF_UINT
+check_type_size(ulong SIZEOF_ULONG) # sets HAVE_SIZEOF_ULONG
+check_type_size(ulonglong SIZEOF_ULONGLONG) # sets HAVE_SIZEOF_ULONGLONG
+check_type_size(ushort SIZEOF_USHORT) # sets HAVE_SIZEOF_USHORT
+set(CMAKE_EXTRA_INCLUDE_FILES)
+##########
+if(NOT HAVE_SIZEOF_LONGLONG)
+  set(longlong "long long") # Define to `long long' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_SIZE_T)
+  set(size_t "unsigned") # Define to `unsigned' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_SSIZE_T AND NOT WIN32) # TRICKY: don't define on Windows, see jas_config2.h
+  set(ssize_t "int") # Define to `int' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_UCHAR)
+  set(uchar "unsigned char") # Define to `unsigned char' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_UINT)
+  set(uint "unsigned int") # Define to `unsigned int' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_ULONG)
+  set(ulong "unsigned long") # Define to `unsigned long' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_ULONGLONG)
+  set(ulonglong "unsigned long long") # Define to `unsigned long long' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_USHORT)
+  set(ushort "unsigned short") # Define to `unsigned short' if <sys/types.h> does not define.
+endif()
+########################################
+# Name of package
+file(STRINGS jasper.spec PACKAGE REGEX "^%define[\t ]+package_name[ \t]+.")
+string(REGEX REPLACE "^%define[\t ]+package_name([ \t]+)" "" PACKAGE ${PACKAGE})
+# Version number of package
+file(STRINGS jasper.spec VERSION REGEX "^%define[\t ]+ver[ \t]+([0-9]+)\\.([0-9]+)\\.([0-9]+)?")
+string(REGEX REPLACE "^%define[\t ]+ver([ \t]+)" "" VERSION ${VERSION})
+set(JAS_VERSION ${VERSION})
+# Define to the address where bug reports for this package should be sent.
+set(PACKAGE_BUGREPORT "http://groups.yahoo.com/group/jasper-discussion")
+# Define to the full name of this package.
+set(PACKAGE_NAME ${PACKAGE})
+# Define to the version of this package.
+set(PACKAGE_VERSION ${VERSION})
+# Define to the full name and version of this package.
+set(PACKAGE_STRING "${PACKAGE} ${PACKAGE_VERSION}")
+# Define to the one symbol short name of this package.
+set(PACKAGE_TARNAME ${PACKAGE})
+########################################
+option(DEBUG "Extra debugging support" FALSE)
+option(DEBUG_MEMALLOC "Debugging memory allocator" FALSE)
+option(DEBUG_OVERFLOW "Debugging overflow detection" FALSE)
+list(APPEND cmakedefine
+  DEBUG
+  DEBUG_MEMALLOC
+  DEBUG_OVERFLOW
+  )
+########################################
+# Define to 1 if you don't have `vprintf' but do have `_doprnt'.
+if(NOT HAVE_VPRINTF)
+check_c_source_compiles("
+/* Define _doprnt to an innocuous variant, in case <limits.h> declares _doprnt.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define _doprnt innocuous__doprnt
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char _doprnt (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef _doprnt
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern \"C\"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char _doprnt ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub__doprnt) || defined (__stub____doprnt)
+choke me
+#else
+char (*f) () = _doprnt;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != _doprnt;
+  ;
+  return 0;
+}
+" HAVE_DOPRNT # TODO: not used in code?
+  )
+endif()
+list(APPEND cmakedefine01 HAVE_DOPRNT)
+########################################
+# Have variable length arrays
+check_c_source_compiles("
+int main()
+{
+  int n;
+  int foo[n];
+  ;
+  return 0;
+}
+" HAVE_VLA
+  )
+list(APPEND cmakedefine01 HAVE_VLA)
+########################################
+set(JAS_CONFIGURE TRUE)
+list(APPEND cmakedefine01 JAS_CONFIGURE)
+########################################
+# Define to 1 if you have the ANSI C header files.
+set(STDC_HEADERS TRUE) #TODO: determine if true - only used in configure?
+list(APPEND cmakedefine01 STDC_HEADERS)
+########################################
+# Define to 1 if the X Window System is missing or not being used.
+set(X_DISPLAY_MISSING FALSE) #TODO: determine if false, not used in code?
+list(APPEND cmakedefine01 X_DISPLAY_MISSING)
+########################################
+# Define to empty if `const' does not conform to ANSI C.
+check_c_source_compiles("
+int main()
+{
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this sort of thing.  */
+  typedef int charset[2];
+  const charset cs = { 0, 0 };
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = \"string\";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
+       \"k.c\", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+  ;
+  return 0;
+}
+" ANSI_CONST
+  )
+if(NOT ANSI_CONST)
+  set(const empty)
+endif()
+list(APPEND cmakedefine const)
+########################################
+unset(inline)
+########################################
+foreach(var ${cmakedefine01})
+  set_define(${var} 1)
+endforeach()
+foreach(var ${cmakedefine})
+  set_define(${var})
+endforeach()
+########################################
+configure_file(${CMAKE_SOURCE_DIR}/src/libjasper/include/jasper/jas_config.h.in .)
+configure_file(${CMAKE_BINARY_DIR}/jas_config.h.in ${PROJECT_BINARY_DIR}/jasper/jas_config.h)
+include_directories(${PROJECT_BINARY_DIR})
+if(EXISTS ${CMAKE_SOURCE_DIR}/src/libjasper/include/jasper/jas_config.h)
+  file(REMOVE ${CMAKE_SOURCE_DIR}/src/libjasper/include/jasper/jas_config.h)
+endif()
+################################################################################
+set(CMAKE_REQUIRED_LIBRARIES)
+set(CMAKE_REQUIRED_DEFINITIONS)
diff --git a/src/appl/CMakeLists.txt b/src/appl/CMakeLists.txt
new file mode 100644
index 0000000..ac6fa93
--- /dev/null
+++ b/src/appl/CMakeLists.txt
@@ -0,0 +1,5 @@
+set(exes imgcmp jasper)
+foreach(exe ${exes})
+  add_executable(${exe} ${exe}.c)
+  target_link_libraries(${exe} libjasper ${JAS_SYSTEM_LIBS})
+endforeach()
diff --git a/src/appl/imgcmp.c b/src/appl/imgcmp.c
index 255b581..83fec87 100644
--- a/src/appl/imgcmp.c
+++ b/src/appl/imgcmp.c
@@ -507,6 +507,7 @@ jas_image_t *makediffimage(jas_matrix_t *origdata, jas_matrix_t *recondata)
 
 	for (i = 0; i < 3; ++i) {
 		if (!(diffdata[i] = jas_matrix_create(height, width))) {
+			jas_image_destroy(diffimage);
 			fprintf(stderr, "internal error\n");
 			return 0;
 		}
@@ -534,6 +535,7 @@ jas_image_t *makediffimage(jas_matrix_t *origdata, jas_matrix_t *recondata)
 
 	for (i = 0; i < 3; ++i) {
 		if (jas_image_writecmpt(diffimage, i, 0, 0, width, height, diffdata[i])) {
+			jas_image_destroy(diffimage);
 			return 0;
 		}
 	}
diff --git a/src/libjasper/CMakeLists.txt b/src/libjasper/CMakeLists.txt
new file mode 100644
index 0000000..8c69a5b
--- /dev/null
+++ b/src/libjasper/CMakeLists.txt
@@ -0,0 +1,180 @@
+set(lib_name libjasper)
+#######################################
+set(base_srcs
+  base/jas_cm.c
+  base/jas_debug.c
+  base/jas_getopt.c
+  base/jas_icc.c
+  base/jas_iccdata.c
+  base/jas_image.c
+  base/jas_init.c
+  base/jas_malloc.c
+  base/jas_seq.c
+  base/jas_stream.c
+  base/jas_string.c
+  base/jas_tmr.c
+  base/jas_tvp.c
+  base/jas_version.c
+  )
+source_group(base FILES ${base_srcs})
+list(APPEND ${lib_name}_libsrcs ${base_srcs})
+###################
+set(bmp_srcs
+  bmp/bmp_cod.c
+  bmp/bmp_cod.h
+  bmp/bmp_dec.c
+  bmp/bmp_enc.c
+  bmp/bmp_enc.h
+  )
+source_group(bmp FILES ${bmp_srcs})
+list(APPEND ${lib_name}_libsrcs ${bmp_srcs})
+###################
+set(include_srcs
+  include/jasper/jas_cm.h
+  include/jasper/jas_config2.h
+  include/jasper/jas_debug.h
+  include/jasper/jas_fix.h
+  include/jasper/jas_getopt.h
+  include/jasper/jas_icc.h
+  include/jasper/jas_image.h
+  include/jasper/jas_init.h
+  include/jasper/jas_malloc.h
+  include/jasper/jas_math.h
+  include/jasper/jasper.h
+  include/jasper/jas_seq.h
+  include/jasper/jas_stream.h
+  include/jasper/jas_string.h
+  include/jasper/jas_tmr.h
+  include/jasper/jas_tvp.h
+  include/jasper/jas_types.h
+  include/jasper/jas_version.h
+  ${PROJECT_BINARY_DIR}/jasper/jas_config.h
+  )
+source_group(include FILES ${include_srcs})
+list(APPEND ${lib_name}_libsrcs ${include_srcs})
+###################
+set(jp2_srcs
+  jp2/jp2_cod.c
+  jp2/jp2_cod.h
+  jp2/jp2_dec.c
+  jp2/jp2_dec.h
+  jp2/jp2_enc.c
+  )
+source_group(jp2 FILES ${jp2_srcs})
+list(APPEND ${lib_name}_libsrcs ${jp2_srcs})
+###################
+set(jpc_srcs
+  jpc/jpc_bs.c
+  jpc/jpc_bs.h
+  jpc/jpc_cod.h
+  jpc/jpc_cs.c
+  jpc/jpc_cs.h
+  jpc/jpc_dec.c
+  jpc/jpc_dec.h
+  jpc/jpc_enc.c
+  jpc/jpc_enc.h
+  jpc/jpc_fix.h
+  jpc/jpc_flt.h
+  jpc/jpc_math.c
+  jpc/jpc_math.h
+  jpc/jpc_mct.c
+  jpc/jpc_mct.h
+  jpc/jpc_mqcod.c
+  jpc/jpc_mqcod.h
+  jpc/jpc_mqdec.c
+  jpc/jpc_mqdec.h
+  jpc/jpc_mqenc.c
+  jpc/jpc_mqenc.h
+  jpc/jpc_qmfb.c
+  jpc/jpc_qmfb.h
+  jpc/jpc_t1cod.c
+  jpc/jpc_t1cod.h
+  jpc/jpc_t1dec.c
+  jpc/jpc_t1dec.h
+  jpc/jpc_t1enc.c
+  jpc/jpc_t1enc.h
+  jpc/jpc_t2cod.c
+  jpc/jpc_t2cod.h
+  jpc/jpc_t2dec.c
+  jpc/jpc_t2dec.h
+  jpc/jpc_t2enc.c
+  jpc/jpc_t2enc.h
+  jpc/jpc_tagtree.c
+  jpc/jpc_tagtree.h
+  jpc/jpc_tsfb.c
+  jpc/jpc_tsfb.h
+  jpc/jpc_util.c
+  jpc/jpc_util.h
+  )
+source_group(jpc FILES ${jpc_srcs})
+list(APPEND ${lib_name}_libsrcs ${jpc_srcs})
+###################
+set(jpg_srcs
+  jpg/jpg_cod.h
+  jpg/jpg_dummy.c
+  jpg/jpg_val.c
+  )
+source_group(jpg FILES ${jpg_srcs})
+list(APPEND ${lib_name}_libsrcs ${jpg_srcs})
+###################
+set(mif_srcs
+  mif/mif_cod.c
+  mif/mif_cod.h
+  )
+source_group(mif FILES ${mif_srcs})
+list(APPEND ${lib_name}_libsrcs ${mif_srcs})
+###################
+set(pgx_srcs
+  pgx/pgx_cod.c
+  pgx/pgx_cod.h
+  pgx/pgx_dec.c
+  pgx/pgx_enc.c
+  pgx/pgx_enc.h
+  )
+source_group(pgx FILES ${pgx_srcs})
+list(APPEND ${lib_name}_libsrcs ${pgx_srcs})
+###################
+set(pnm_srcs
+  pnm/pnm_cod.c
+  pnm/pnm_cod.h
+  pnm/pnm_dec.c
+  pnm/pnm_enc.c
+  pnm/pnm_enc.h
+  )
+source_group(pnm FILES ${pnm_srcs})
+list(APPEND ${lib_name}_libsrcs ${pnm_srcs})
+###################
+set(ras_srcs
+  ras/ras_cod.c
+  ras/ras_cod.h
+  ras/ras_dec.c
+  ras/ras_enc.c
+  ras/ras_enc.h
+  )
+source_group(ras FILES ${ras_srcs})
+list(APPEND ${lib_name}_libsrcs ${ras_srcs})
+#######################################
+add_library(${lib_name} STATIC ${${lib_name}_libsrcs})
+target_include_directories(${lib_name} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+  )
+if(MSVC)
+  target_compile_definitions(${lib_name} PRIVATE -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_WARNINGS)
+endif()
+# strip off the "lib" prefix, since it's already libjasper
+set_target_properties(${lib_name} PROPERTIES PREFIX "")
+#######################################
+set(targetsFile ${PROJECT_NAME}-targets)
+install(TARGETS ${lib_name} EXPORT ${targetsFile}
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  )
+install(FILES ${include_srcs} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME})
+if(DEFINED XP_NAMESPACE)
+  set(nameSpace NAMESPACE ${XP_NAMESPACE}::)
+endif()
+if(NOT DEFINED XP_INSTALL_CMAKEDIR)
+  set(XP_INSTALL_CMAKEDIR ${CMAKE_INSTALL_DATADIR}/cmake)
+endif()
+install(EXPORT ${targetsFile} DESTINATION ${XP_INSTALL_CMAKEDIR} ${nameSpace})
diff --git a/src/libjasper/base/jas_cm.c b/src/libjasper/base/jas_cm.c
index 77514dd..c30f339 100644
--- a/src/libjasper/base/jas_cm.c
+++ b/src/libjasper/base/jas_cm.c
@@ -355,6 +355,8 @@ jas_cmprof_t *jas_cmprof_copy(jas_cmprof_t *prof)
 	}
 	return newprof;
 error:
+	if (newprof)
+		jas_cmprof_destroy(newprof);
 	return 0;
 }
 
@@ -458,6 +460,8 @@ jas_cmxform_t *jas_cmxform_create(jas_cmprof_t *inprof, jas_cmprof_t *outprof,
 	}
 	return xform;
 error:
+	if (xform)
+		jas_cmxform_destroy(xform);
 	return 0;
 }
 
@@ -614,6 +618,8 @@ static jas_cmpxformseq_t *jas_cmpxformseq_copy(jas_cmpxformseq_t *pxformseq)
 		goto error;
 	return newpxformseq;
 error:
+	if (newpxformseq)
+		jas_cmpxformseq_destroy(newpxformseq);
 	return 0;
 }
 
@@ -704,8 +710,7 @@ static int jas_cmpxformseq_resize(jas_cmpxformseq_t *pxformseq, int n)
 {
 	jas_cmpxform_t **p;
 	assert(n >= pxformseq->numpxforms);
-	p = (!pxformseq->pxforms) ? jas_malloc(n * sizeof(jas_cmpxform_t *)) :
-	  jas_realloc(pxformseq->pxforms, n * sizeof(jas_cmpxform_t *));
+	p = jas_realloc2(pxformseq->pxforms, n, sizeof(jas_cmpxform_t *));
 	if (!p) {
 		return -1;
 	}
@@ -889,13 +894,13 @@ static int jas_cmshapmatlut_set(jas_cmshapmatlut_t *lut, jas_icccurv_t *curv)
 	jas_cmshapmatlut_cleanup(lut);
 	if (curv->numents == 0) {
 		lut->size = 2;
-		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))
+		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
 			goto error;
 		lut->data[0] = 0.0;
 		lut->data[1] = 1.0;
 	} else if (curv->numents == 1) {
 		lut->size = 256;
-		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))
+		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
 			goto error;
 		gamma = curv->ents[0] / 256.0;
 		for (i = 0; i < lut->size; ++i) {
@@ -903,7 +908,7 @@ static int jas_cmshapmatlut_set(jas_cmshapmatlut_t *lut, jas_icccurv_t *curv)
 		}
 	} else {
 		lut->size = curv->numents;
-		if (!(lut->data = jas_malloc(lut->size * sizeof(jas_cmreal_t))))
+		if (!(lut->data = jas_alloc2(lut->size, sizeof(jas_cmreal_t))))
 			goto error;
 		for (i = 0; i < lut->size; ++i) {
 			lut->data[i] = curv->ents[i] / 65535.0;
@@ -953,7 +958,7 @@ static int jas_cmshapmatlut_invert(jas_cmshapmatlut_t *invlut,
 			return -1;
 		}
 	}
-	if (!(invlut->data = jas_malloc(n * sizeof(jas_cmreal_t))))
+	if (!(invlut->data = jas_alloc2(n, sizeof(jas_cmreal_t))))
 		return -1;
 	invlut->size = n;
 	for (i = 0; i < invlut->size; ++i) {
diff --git a/src/libjasper/base/jas_icc.c b/src/libjasper/base/jas_icc.c
index e5a0a2e..c13d7ac 100644
--- a/src/libjasper/base/jas_icc.c
+++ b/src/libjasper/base/jas_icc.c
@@ -266,7 +266,6 @@ jas_iccprof_t *jas_iccprof_load(jas_stream_t *in)
 	jas_iccattrval_t *attrval;
 	jas_iccattrval_t *prevattrval;
 	jas_icctagtabent_t *tagtabent;
-	jas_iccattrvalinfo_t *attrvalinfo;
 	int i;
 	int len;
 
@@ -300,6 +299,7 @@ jas_iccprof_t *jas_iccprof_load(jas_stream_t *in)
 				if (jas_iccprof_setattr(prof, tagtabent->tag, attrval))
 					goto error;
 				jas_iccattrval_destroy(attrval);
+				attrval = 0;
 			} else {
 #if 0
 				jas_eprintf("warning: skipping unknown tag type\n");
@@ -325,7 +325,7 @@ jas_iccprof_t *jas_iccprof_load(jas_stream_t *in)
 			goto error;
 		}
 		curoff += 8;
-		if (!(attrvalinfo = jas_iccattrvalinfo_lookup(type))) {
+		if (!jas_iccattrvalinfo_lookup(type)) {
 #if 0
 			jas_eprintf("warning: skipping unknown tag type\n");
 #endif
@@ -373,7 +373,7 @@ int jas_iccprof_save(jas_iccprof_t *prof, jas_stream_t *out)
 	jas_icctagtab_t *tagtab;
 
 	tagtab = &prof->tagtab;
-	if (!(tagtab->ents = jas_malloc(prof->attrtab->numattrs *
+	if (!(tagtab->ents = jas_alloc2(prof->attrtab->numattrs,
 	  sizeof(jas_icctagtabent_t))))
 		goto error;
 	tagtab->numents = prof->attrtab->numattrs;
@@ -522,7 +522,7 @@ static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab)
 	}
 	if (jas_iccgetuint32(in, &tagtab->numents))
 		goto error;
-	if (!(tagtab->ents = jas_malloc(tagtab->numents *
+	if (!(tagtab->ents = jas_alloc2(tagtab->numents,
 	  sizeof(jas_icctagtabent_t))))
 		goto error;
 	tagtabent = tagtab->ents;
@@ -743,8 +743,7 @@ static int jas_iccattrtab_resize(jas_iccattrtab_t *tab, int maxents)
 {
 	jas_iccattr_t *newattrs;
 	assert(maxents >= tab->numattrs);
-	newattrs = tab->attrs ? jas_realloc(tab->attrs, maxents *
-	  sizeof(jas_iccattr_t)) : jas_malloc(maxents * sizeof(jas_iccattr_t));
+	newattrs = jas_realloc2(tab->attrs, maxents, sizeof(jas_iccattr_t));
 	if (!newattrs)
 		return -1;
 	tab->attrs = newattrs;
@@ -999,7 +998,7 @@ static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 
 	if (jas_iccgetuint32(in, &curv->numents))
 		goto error;
-	if (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))
+	if (!(curv->ents = jas_alloc2(curv->numents, sizeof(jas_iccuint16_t))))
 		goto error;
 	for (i = 0; i < curv->numents; ++i) {
 		if (jas_iccgetuint16(in, &curv->ents[i]))
@@ -1011,7 +1010,6 @@ static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 	return 0;
 
 error:
-	jas_icccurv_destroy(attrval);
 	return -1;
 }
 
@@ -1100,7 +1098,7 @@ static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 	if (jas_iccgetuint32(in, &txtdesc->uclangcode) ||
 	  jas_iccgetuint32(in, &txtdesc->uclen))
 		goto error;
-	if (!(txtdesc->ucdata = jas_malloc(txtdesc->uclen * 2)))
+	if (!(txtdesc->ucdata = jas_alloc2(txtdesc->uclen, 2)))
 		goto error;
 	if (jas_stream_read(in, txtdesc->ucdata, txtdesc->uclen * 2) !=
 	  JAS_CAST(int, txtdesc->uclen * 2))
@@ -1129,7 +1127,6 @@ static int jas_icctxtdesc_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 #endif
 	return 0;
 error:
-	jas_icctxtdesc_destroy(attrval);
 	return -1;
 }
 
@@ -1208,8 +1205,6 @@ static int jas_icctxt_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 		goto error;
 	return 0;
 error:
-	if (txt->string)
-		jas_free(txt->string);
 	return -1;
 }
 
@@ -1292,17 +1287,17 @@ static int jas_icclut8_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 	  jas_iccgetuint16(in, &lut8->numouttabents))
 		goto error;
 	clutsize = jas_iccpowi(lut8->clutlen, lut8->numinchans) * lut8->numoutchans;
-	if (!(lut8->clut = jas_malloc(clutsize * sizeof(jas_iccuint8_t))) ||
-	  !(lut8->intabsbuf = jas_malloc(lut8->numinchans *
-	  lut8->numintabents * sizeof(jas_iccuint8_t))) ||
-	  !(lut8->intabs = jas_malloc(lut8->numinchans *
+	if (!(lut8->clut = jas_alloc2(clutsize, sizeof(jas_iccuint8_t))) ||
+	  !(lut8->intabsbuf = jas_alloc3(lut8->numinchans,
+	  lut8->numintabents, sizeof(jas_iccuint8_t))) ||
+	  !(lut8->intabs = jas_alloc2(lut8->numinchans,
 	  sizeof(jas_iccuint8_t *))))
 		goto error;
 	for (i = 0; i < lut8->numinchans; ++i)
 		lut8->intabs[i] = &lut8->intabsbuf[i * lut8->numintabents];
-	if (!(lut8->outtabsbuf = jas_malloc(lut8->numoutchans *
-	  lut8->numouttabents * sizeof(jas_iccuint8_t))) ||
-	  !(lut8->outtabs = jas_malloc(lut8->numoutchans *
+	if (!(lut8->outtabsbuf = jas_alloc3(lut8->numoutchans,
+	  lut8->numouttabents, sizeof(jas_iccuint8_t))) ||
+	  !(lut8->outtabs = jas_alloc2(lut8->numoutchans,
 	  sizeof(jas_iccuint8_t *))))
 		goto error;
 	for (i = 0; i < lut8->numoutchans; ++i)
@@ -1330,7 +1325,6 @@ static int jas_icclut8_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 		goto error;
 	return 0;
 error:
-	jas_icclut8_destroy(attrval);
 	return -1;
 }
 
@@ -1461,17 +1455,17 @@ static int jas_icclut16_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 	  jas_iccgetuint16(in, &lut16->numouttabents))
 		goto error;
 	clutsize = jas_iccpowi(lut16->clutlen, lut16->numinchans) * lut16->numoutchans;
-	if (!(lut16->clut = jas_malloc(clutsize * sizeof(jas_iccuint16_t))) ||
-	  !(lut16->intabsbuf = jas_malloc(lut16->numinchans *
-	  lut16->numintabents * sizeof(jas_iccuint16_t))) ||
-	  !(lut16->intabs = jas_malloc(lut16->numinchans *
+	if (!(lut16->clut = jas_alloc2(clutsize, sizeof(jas_iccuint16_t))) ||
+	  !(lut16->intabsbuf = jas_alloc3(lut16->numinchans,
+	  lut16->numintabents, sizeof(jas_iccuint16_t))) ||
+	  !(lut16->intabs = jas_alloc2(lut16->numinchans,
 	  sizeof(jas_iccuint16_t *))))
 		goto error;
 	for (i = 0; i < lut16->numinchans; ++i)
 		lut16->intabs[i] = &lut16->intabsbuf[i * lut16->numintabents];
-	if (!(lut16->outtabsbuf = jas_malloc(lut16->numoutchans *
-	  lut16->numouttabents * sizeof(jas_iccuint16_t))) ||
-	  !(lut16->outtabs = jas_malloc(lut16->numoutchans *
+	if (!(lut16->outtabsbuf = jas_alloc3(lut16->numoutchans,
+	  lut16->numouttabents, sizeof(jas_iccuint16_t))) ||
+	  !(lut16->outtabs = jas_alloc2(lut16->numoutchans,
 	  sizeof(jas_iccuint16_t *))))
 		goto error;
 	for (i = 0; i < lut16->numoutchans; ++i)
@@ -1499,7 +1493,6 @@ static int jas_icclut16_input(jas_iccattrval_t *attrval, jas_stream_t *in,
 		goto error;
 	return 0;
 error:
-	jas_icclut16_destroy(attrval);
 	return -1;
 }
 
@@ -1699,6 +1692,8 @@ jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
 	jas_stream_close(in);
 	return prof;
 error:
+	if (in)
+		jas_stream_close(in);
 	return 0;
 }
 
diff --git a/src/libjasper/base/jas_image.c b/src/libjasper/base/jas_image.c
index 876debb..64883aa 100644
--- a/src/libjasper/base/jas_image.c
+++ b/src/libjasper/base/jas_image.c
@@ -142,7 +142,7 @@ jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
 	image->inmem_ = true;
 
 	/* Allocate memory for the per-component information. */
-	if (!(image->cmpts_ = jas_malloc(image->maxcmpts_ *
+	if (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,
 	  sizeof(jas_image_cmpt_t *)))) {
 		jas_image_destroy(image);
 		return 0;
@@ -210,7 +210,10 @@ jas_image_t *jas_image_copy(jas_image_t *image)
 	jas_image_t *newimage;
 	int cmptno;
 
-	newimage = jas_image_create0();
+	if (!(newimage = jas_image_create0())) {
+		goto error;
+	}
+
 	if (jas_image_growcmpts(newimage, image->numcmpts_)) {
 		goto error;
 	}
@@ -265,15 +268,19 @@ static jas_image_cmpt_t *jas_image_cmpt_copy(jas_image_cmpt_t *cmpt)
 	newcmpt->cps_ = cmpt->cps_;
 	newcmpt->type_ = cmpt->type_;
 	if (!(newcmpt->stream_ = jas_stream_memopen(0, 0))) {
+		jas_image_cmpt_destroy(newcmpt);
 		return 0;
 	}
 	if (jas_stream_seek(cmpt->stream_, 0, SEEK_SET)) {
+		jas_image_cmpt_destroy(newcmpt);
 		return 0;
 	}
 	if (jas_stream_copy(newcmpt->stream_, cmpt->stream_, -1)) {
+		jas_image_cmpt_destroy(newcmpt);
 		return 0;
 	}
 	if (jas_stream_seek(newcmpt->stream_, 0, SEEK_SET)) {
+		jas_image_cmpt_destroy(newcmpt);
 		return 0;
 	}
 	return newcmpt;
@@ -426,7 +433,7 @@ int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,
 		return -1;
 	}
 
-	if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
+	if (!height || !width || jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
 		if (jas_matrix_resize(data, height, width)) {
 			return -1;
 		}
@@ -479,7 +486,7 @@ int jas_image_writecmpt(jas_image_t *image, int cmptno, jas_image_coord_t x, jas
 		return -1;
 	}
 
-	if (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
+	if (!height || !width || jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {
 		return -1;
 	}
 
@@ -774,8 +781,7 @@ static int jas_image_growcmpts(jas_image_t *image, int maxcmpts)
 	jas_image_cmpt_t **newcmpts;
 	int cmptno;
 
-	newcmpts = (!image->cmpts_) ? jas_malloc(maxcmpts * sizeof(jas_image_cmpt_t *)) :
-	  jas_realloc(image->cmpts_, maxcmpts * sizeof(jas_image_cmpt_t *));
+	newcmpts = jas_realloc2(image->cmpts_, maxcmpts, sizeof(jas_image_cmpt_t *));
 	if (!newcmpts) {
 		return -1;
 	}
@@ -1441,5 +1447,11 @@ jas_image_dump(outimage, stderr);
 #endif
 	return outimage;
 error:
+	if (xform)
+		jas_cmxform_destroy(xform);
+	if (inimage)
+		jas_image_destroy(inimage);
+	if (outimage)
+		jas_image_destroy(outimage);
 	return 0;
 }
diff --git a/src/libjasper/base/jas_malloc.c b/src/libjasper/base/jas_malloc.c
index 13f7bc8..90658e8 100644
--- a/src/libjasper/base/jas_malloc.c
+++ b/src/libjasper/base/jas_malloc.c
@@ -76,6 +76,9 @@
 
 /* We need the prototype for memset. */
 #include <string.h>
+#include <limits.h>
+#include <errno.h>
+#include <stdint.h>
 
 #include "jasper/jas_malloc.h"
 
@@ -113,18 +116,50 @@ void jas_free(void *ptr)
 
 void *jas_realloc(void *ptr, size_t size)
 {
-	return realloc(ptr, size);
+	return ptr ? realloc(ptr, size) : malloc(size);
 }
 
-void *jas_calloc(size_t nmemb, size_t size)
+void *jas_realloc2(void *ptr, size_t nmemb, size_t size)
+{
+	if (!ptr)
+		return jas_alloc2(nmemb, size);
+	if (nmemb && SIZE_MAX / nmemb < size) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	return jas_realloc(ptr, nmemb * size);
+
+}
+
+void *jas_alloc2(size_t nmemb, size_t size)
+{
+	if (nmemb && SIZE_MAX / nmemb < size) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	return jas_malloc(nmemb * size);
+}
+
+void *jas_alloc3(size_t a, size_t b, size_t c)
 {
-	void *ptr;
 	size_t n;
-	n = nmemb * size;
-	if (!(ptr = jas_malloc(n * sizeof(char)))) {
-		return 0;
+
+	if (a && SIZE_MAX / a < b) {
+		errno = ENOMEM;
+		return NULL;
 	}
-	memset(ptr, 0, n);
+
+	return jas_alloc2(a*b, c);
+}
+
+void *jas_calloc(size_t nmemb, size_t size)
+{
+	void *ptr;
+
+	ptr = jas_alloc2(nmemb, size);
+	if (ptr)
+		memset(ptr, 0, nmemb*size);
 	return ptr;
 }
 
diff --git a/src/libjasper/base/jas_seq.c b/src/libjasper/base/jas_seq.c
index 16e1778..ed0c7cf 100644
--- a/src/libjasper/base/jas_seq.c
+++ b/src/libjasper/base/jas_seq.c
@@ -114,7 +114,7 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 	matrix->datasize_ = numrows * numcols;
 
 	if (matrix->maxrows_ > 0) {
-		if (!(matrix->rows_ = jas_malloc(matrix->maxrows_ *
+		if (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,
 		  sizeof(jas_seqent_t *)))) {
 			jas_matrix_destroy(matrix);
 			return 0;
@@ -122,7 +122,7 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)
 	}
 
 	if (matrix->datasize_ > 0) {
-		if (!(matrix->data_ = jas_malloc(matrix->datasize_ *
+		if (!(matrix->data_ = jas_alloc2(matrix->datasize_,
 		  sizeof(jas_seqent_t)))) {
 			jas_matrix_destroy(matrix);
 			return 0;
@@ -220,7 +220,11 @@ void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0, int c0,
 	mat0->numrows_ = r1 - r0 + 1;
 	mat0->numcols_ = c1 - c0 + 1;
 	mat0->maxrows_ = mat0->numrows_;
-	mat0->rows_ = jas_malloc(mat0->maxrows_ * sizeof(jas_seqent_t *));
+	if (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {
+		jas_matrix_destroy(mat0);
+		return;
+	}
+
 	for (i = 0; i < mat0->numrows_; ++i) {
 		mat0->rows_[i] = mat1->rows_[r0 + i] + c0;
 	}
@@ -262,6 +266,8 @@ void jas_matrix_divpow2(jas_matrix_t *matrix, int n)
 	int rowstep;
 	jas_seqent_t *data;
 
+	if (!matrix || !matrix->numrows_ || !matrix->rows_)
+		return;
 	rowstep = jas_matrix_rowstep(matrix);
 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 	  rowstart += rowstep) {
@@ -282,6 +288,8 @@ void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval, jas_seqent_t max
 	jas_seqent_t *data;
 	int rowstep;
 
+	if (!matrix || !matrix->numrows_ || !matrix->rows_)
+		return;
 	rowstep = jas_matrix_rowstep(matrix);
 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 	  rowstart += rowstep) {
@@ -307,6 +315,8 @@ void jas_matrix_asr(jas_matrix_t *matrix, int n)
 	jas_seqent_t *data;
 
 	assert(n >= 0);
+	if (!matrix || !matrix->numrows_ || !matrix->rows_)
+		return;
 	rowstep = jas_matrix_rowstep(matrix);
 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 	  rowstart += rowstep) {
@@ -325,6 +335,8 @@ void jas_matrix_asl(jas_matrix_t *matrix, int n)
 	int rowstep;
 	jas_seqent_t *data;
 
+	if (!matrix || !matrix->numrows_ || !matrix->rows_)
+		return;
 	rowstep = jas_matrix_rowstep(matrix);
 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 	  rowstart += rowstep) {
@@ -367,6 +379,8 @@ void jas_matrix_setall(jas_matrix_t *matrix, jas_seqent_t val)
 	int rowstep;
 	jas_seqent_t *data;
 
+	if (!matrix || !matrix->numrows_ || !matrix->rows_)
+		return;
 	rowstep = jas_matrix_rowstep(matrix);
 	for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 	  rowstart += rowstep) {
@@ -395,7 +409,7 @@ jas_matrix_t *jas_seq2d_input(FILE *in)
 	if (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))
 		return 0;
 
-	if (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {
+	if (!matrix || jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {
 		abort();
 	}
 
diff --git a/src/libjasper/base/jas_stream.c b/src/libjasper/base/jas_stream.c
index 9a88556..d7151c7 100644
--- a/src/libjasper/base/jas_stream.c
+++ b/src/libjasper/base/jas_stream.c
@@ -212,7 +212,7 @@ jas_stream_t *jas_stream_memopen(char *buf, int bufsize)
 	if (buf) {
 		obj->buf_ = (unsigned char *) buf;
 	} else {
-		obj->buf_ = jas_malloc(obj->bufsize_ * sizeof(char));
+		obj->buf_ = jas_malloc(obj->bufsize_);
 		obj->myalloc_ = 1;
 	}
 	if (!obj->buf_) {
@@ -364,8 +364,11 @@ jas_stream_t *jas_stream_tmpfile()
 	obj->pathname[0] = '\0';
 	stream->obj_ = obj;
 
+#ifdef _MSC_VER
 	/* Choose a file name. */
-	tmpnam(obj->pathname);
+	char *temppathname = tempnam(NULL, "jas");
+	strcpy(obj->pathname, temppathname);
+	free(temppathname);
 
 	/* Open the underlying file. */
 	if ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,
@@ -373,6 +376,16 @@ jas_stream_t *jas_stream_tmpfile()
 		jas_stream_destroy(stream);
 		return 0;
 	}
+#else
+	/* Choose a file name. */
+	snprintf(obj->pathname, L_tmpnam, "%s/tmp.XXXXXXXXXX", P_tmpdir);
+
+	/* Open the underlying file. */
+	if ((obj->fd = mkstemp(obj->pathname)) < 0) {
+		jas_stream_destroy(stream);
+		return 0;
+	}
+#endif
 
 	/* Unlink the file so that it will disappear if the program
 	terminates abnormally. */
@@ -381,8 +394,13 @@ jas_stream_t *jas_stream_tmpfile()
 	For example, under Microsoft Windows the unlink operation will fail,
 	since the file is open. */
 	if (unlink(obj->pathname)) {
+#ifdef _MSC_VER
 		/* We will try unlinking the file again after it is closed. */
 		obj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;
+#else
+		jas_stream_destroy(stream);
+		return 0;
+#endif
 	}
 
 	/* Use full buffering. */
@@ -553,7 +571,7 @@ int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)
 	int ret;
 
 	va_start(ap, fmt);
-	ret = vsprintf(buf, fmt, ap);
+	ret = vsnprintf(buf, sizeof buf, fmt, ap);
 	jas_stream_puts(stream, buf);
 	va_end(ap);
 	return ret;
@@ -992,7 +1010,7 @@ static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 	unsigned char *buf;
 
 	assert(m->buf_);
-	if (!(buf = jas_realloc(m->buf_, bufsize * sizeof(unsigned char)))) {
+	if (!(buf = jas_realloc(m->buf_, bufsize))) {
 		return -1;
 	}
 	m->buf_ = buf;
diff --git a/src/libjasper/bmp/bmp_dec.c b/src/libjasper/bmp/bmp_dec.c
index 4cb0df3..7a6dcb1 100644
--- a/src/libjasper/bmp/bmp_dec.c
+++ b/src/libjasper/bmp/bmp_dec.c
@@ -283,7 +283,7 @@ static bmp_info_t *bmp_getinfo(jas_stream_t *in)
 	}
 
 	if (info->numcolors > 0) {
-		if (!(info->palents = jas_malloc(info->numcolors *
+		if (!(info->palents = jas_alloc2(info->numcolors,
 		  sizeof(bmp_palent_t)))) {
 			bmp_info_destroy(info);
 			return 0;
diff --git a/src/libjasper/bmp/bmp_enc.c b/src/libjasper/bmp/bmp_enc.c
index 26c658c..4cb2294 100644
--- a/src/libjasper/bmp/bmp_enc.c
+++ b/src/libjasper/bmp/bmp_enc.c
@@ -205,16 +205,19 @@ int bmp_encode(jas_image_t *image, jas_stream_t *out, char *optstr)
 
 	/* Write the bitmap header. */
 	if (bmp_puthdr(out, &hdr)) {
+		bmp_info_destroy(info);
 		return -1;
 	}
 
 	/* Write the bitmap information. */
 	if (bmp_putinfo(out, info)) {
+		bmp_info_destroy(info);
 		return -1;
 	}
 
 	/* Write the bitmap data. */
 	if (bmp_putdata(out, info, image, enc->cmpts)) {
+		bmp_info_destroy(info);
 		return -1;
 	}
 
diff --git a/src/libjasper/include/jasper/jas_config.h.in b/src/libjasper/include/jasper/jas_config.h.in
index a7375de..4a979bb 100644
--- a/src/libjasper/include/jasper/jas_config.h.in
+++ b/src/libjasper/include/jasper/jas_config.h.in
@@ -1,4 +1,6 @@
-/* src/libjasper/include/jasper/jas_config.h.in.  Generated from configure.ac by autoheader.  */
+/* jasper/jas_config.h.  Generated by configure.cmake.  */
+/* From src/libjasper/include/jasper/jas_config.h.cmake.in.  */
+/* Which was Copied, then modified from src/libjasper/include/jasper/jas_config.h.in.  */
 
 
 /* Avoid problems due to multiple inclusion. */
@@ -6,167 +8,155 @@
 #define JAS_CONFIG_H
 
 /* This preprocessor symbol identifies the version of JasPer. */
-#undef	JAS_VERSION
+#cmakedefine	JAS_VERSION "@JAS_VERSION@"
 /* If configure is being used, this symbol will be defined automatically
   at this point in the configuration header file. */
 
-/* The preprocessor symbol JAS_WIN_MSVC_BUILD should not be defined
-  unless the JasPer software is being built under Microsoft Windows
-  using Microsoft Visual C. */
-#if !defined(JAS_WIN_MSVC_BUILD)
-/* A configure-based build is being used. */
-
-
 
 /* Extra debugging support */
-#undef DEBUG
+#@DEFINE_DEBUG@ DEBUG
 
 /* Debugging memory allocator */
-#undef DEBUG_MEMALLOC
+#@DEFINE_DEBUG_MEMALLOC@ DEBUG_MEMALLOC
 
 /* Debugging overflow detection */
-#undef DEBUG_OVERFLOW
+#@DEFINE_DEBUG_OVERFLOW@ DEBUG_OVERFLOW
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
+#@DEFINE_HAVE_DLFCN_H@ HAVE_DLFCN_H
 
 /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
-#undef HAVE_DOPRNT
+#@DEFINE_HAVE_DOPRNT@ HAVE_DOPRNT
 
 /* Define to 1 if you have the <fcntl.h> header file. */
-#undef HAVE_FCNTL_H
+#@DEFINE_HAVE_FCNTL_H@ HAVE_FCNTL_H
 
 /* Define to 1 if you have the `getrusage' function. */
-#undef HAVE_GETRUSAGE
+#@DEFINE_HAVE_GETRUSAGE@ HAVE_GETRUSAGE
 
 /* Define to 1 if you have the `gettimeofday' function. */
-#undef HAVE_GETTIMEOFDAY
+#@DEFINE_HAVE_GETTIMEOFDAY@ HAVE_GETTIMEOFDAY
 
 /* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
+#@DEFINE_HAVE_INTTYPES_H@ HAVE_INTTYPES_H
 
 /* Define to 1 if you have the <io.h> header file. */
-#undef HAVE_IO_H
+#@DEFINE_HAVE_IO_H@ HAVE_IO_H
 
 /* Define to 1 if you have the `m' library (-lm). */
-#undef HAVE_LIBM
+#@DEFINE_HAVE_LIBM@ HAVE_LIBM
 
 /* Define to 1 if you have the <limits.h> header file. */
-#undef HAVE_LIMITS_H
+#@DEFINE_HAVE_LIMITS_H@ HAVE_LIMITS_H
 
 /* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
+#@DEFINE_HAVE_MEMORY_H@ HAVE_MEMORY_H
 
 /* Define to 1 if you have the <stdbool.h> header file. */
-#undef HAVE_STDBOOL_H
+#@DEFINE_HAVE_STDBOOL_H@ HAVE_STDBOOL_H
 
 /* Define to 1 if you have the <stddef.h> header file. */
-#undef HAVE_STDDEF_H
+#@DEFINE_HAVE_STDDEF_H@ HAVE_STDDEF_H
 
 /* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
+#@DEFINE_HAVE_STDINT_H@ HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
+#@DEFINE_HAVE_STDLIB_H@ HAVE_STDLIB_H
 
 /* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
+#@DEFINE_HAVE_STRINGS_H@ HAVE_STRINGS_H
 
 /* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
+#@DEFINE_HAVE_STRING_H@ HAVE_STRING_H
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
+#@DEFINE_HAVE_SYS_STAT_H@ HAVE_SYS_STAT_H
 
 /* Define to 1 if you have the <sys/time.h> header file. */
-#undef HAVE_SYS_TIME_H
+#@DEFINE_HAVE_SYS_TIME_H@ HAVE_SYS_TIME_H
 
 /* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
+#@DEFINE_HAVE_SYS_TYPES_H@ HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
+#@DEFINE_HAVE_UNISTD_H@ HAVE_UNISTD_H
 
 /* Have variable length arrays */
-#undef HAVE_VLA
+#@DEFINE_HAVE_VLA@ HAVE_VLA
 
 /* Define to 1 if you have the `vprintf' function. */
-#undef HAVE_VPRINTF
+#@DEFINE_HAVE_VPRINTF@ HAVE_VPRINTF
 
 /* Define to 1 if you have the <windows.h> header file. */
-#undef HAVE_WINDOWS_H
+#@DEFINE_HAVE_WINDOWS_H@ HAVE_WINDOWS_H
 
 /* JasPer configure */
-#undef JAS_CONFIGURE
+#@DEFINE_JAS_CONFIGURE@ JAS_CONFIGURE
 
 /* JasPer version */
-#undef JAS_VERSION
+#cmakedefine JAS_VERSION "@JAS_VERSION@"
 
 /* Name of package */
-#undef PACKAGE
+#cmakedefine PACKAGE "@PACKAGE@"
 
 /* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
+#cmakedefine PACKAGE_BUGREPORT "@PACKAGE_BUGREPORT@"
 
 /* Define to the full name of this package. */
-#undef PACKAGE_NAME
+#cmakedefine PACKAGE_NAME "@PACKAGE_NAME@"
 
 /* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
+#cmakedefine PACKAGE_STRING "@PACKAGE_STRING@"
 
 /* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
+#cmakedefine PACKAGE_TARNAME "@PACKAGE_TARNAME@"
 
 /* Define to the version of this package. */
-#undef PACKAGE_VERSION
+#cmakedefine PACKAGE_VERSION "@PACKAGE_VERSION@"
 
 /* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
+#@DEFINE_STDC_HEADERS@ STDC_HEADERS
 
 /* Version number of package */
-#undef VERSION
+#cmakedefine VERSION "@VERSION@"
 
 /* Define to 1 if the X Window System is missing or not being used. */
-#undef X_DISPLAY_MISSING
+#@DEFINE_X_DISPLAY_MISSING@ X_DISPLAY_MISSING
 
 /* Define to empty if `const' does not conform to ANSI C. */
-#undef const
+#@DEFINE_const@ const
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
 #ifndef __cplusplus
-#undef inline
+#cmakedefine inline @inline@
 #endif
 
 /* Define to `long long' if <sys/types.h> does not define. */
-#undef longlong
+#cmakedefine longlong @longlong@
 
 /* Define to `unsigned' if <sys/types.h> does not define. */
-#undef size_t
+#cmakedefine size_t @size_t@
 
 /* Define to `int' if <sys/types.h> does not define. */
-#undef ssize_t
+#cmakedefine ssize_t @ssize_t@
 
 /* Define to `unsigned char' if <sys/types.h> does not define. */
-#undef uchar
+#cmakedefine uchar @uchar@
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef uint
+#cmakedefine uint @uint@
 
 /* Define to `unsigned long' if <sys/types.h> does not define. */
-#undef ulong
+#cmakedefine ulong @ulong@
 
 /* Define to `unsigned long long' if <sys/types.h> does not define. */
-#undef ulonglong
+#cmakedefine ulonglong @ulonglong@
 
 /* Define to `unsigned short' if <sys/types.h> does not define. */
-#undef ushort
+#cmakedefine ushort @ushort@
 
 
-#else
-/* A configure-based build is not being used. */
-#include <jasper/jas_config2.h>
-#endif
-
 #endif
 
diff --git a/src/libjasper/include/jasper/jas_malloc.h b/src/libjasper/include/jasper/jas_malloc.h
index f2a8f8b..258e4c7 100644
--- a/src/libjasper/include/jasper/jas_malloc.h
+++ b/src/libjasper/include/jasper/jas_malloc.h
@@ -95,6 +95,9 @@ extern "C" {
 #define	jas_free	MEMFREE
 #define	jas_realloc	MEMREALLOC
 #define	jas_calloc	MEMCALLOC
+#define jas_alloc2(a, b)	MEMALLOC((a)*(b))
+#define jas_alloc3(a, b, c)	MEMALLOC((a)*(b)*(c))
+#define jas_realloc2(p, a, b)	MEMREALLOC((p), (a)*(b))
 #endif
 
 /******************************************************************************\
@@ -115,6 +118,12 @@ void *jas_realloc(void *ptr, size_t size);
 /* Allocate a block of memory and initialize the contents to zero. */
 void *jas_calloc(size_t nmemb, size_t size);
 
+/* size-checked double allocation .*/
+void *jas_alloc2(size_t, size_t);
+
+void *jas_alloc3(size_t, size_t, size_t);
+
+void *jas_realloc2(void *, size_t, size_t);
 #endif
 
 #ifdef __cplusplus
diff --git a/src/libjasper/include/jasper/jas_stream.h b/src/libjasper/include/jasper/jas_stream.h
index 651bea9..28e719d 100644
--- a/src/libjasper/include/jasper/jas_stream.h
+++ b/src/libjasper/include/jasper/jas_stream.h
@@ -77,6 +77,9 @@
 #include <jasper/jas_config.h>
 
 #include <stdio.h>
+#if defined(HAVE_LIMITS_H)
+#include <limits.h>
+#endif
 #if defined(HAVE_FCNTL_H)
 #include <fcntl.h>
 #endif
@@ -99,6 +102,12 @@ extern "C" {
 #define O_BINARY	0
 #endif
 
+#ifdef PATH_MAX
+#define JAS_PATH_MAX PATH_MAX
+#else
+#define JAS_PATH_MAX 4096
+#endif
+
 /*
  * Stream open flags.
  */
@@ -251,7 +260,7 @@ typedef struct {
 typedef struct {
 	int fd;
 	int flags;
-	char pathname[L_tmpnam + 1];
+	char pathname[JAS_PATH_MAX + 1];
 } jas_stream_fileobj_t;
 
 #define	JAS_STREAM_FILEOBJ_DELONCLOSE	0x01
diff --git a/src/libjasper/jp2/jp2_cod.c b/src/libjasper/jp2/jp2_cod.c
index 83cecb1..d2ea907 100644
--- a/src/libjasper/jp2/jp2_cod.c
+++ b/src/libjasper/jp2/jp2_cod.c
@@ -247,7 +247,7 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	box = 0;
 	tmpstream = 0;
 
-	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
+	if (!(box = jas_calloc(1, sizeof(jp2_box_t)))) {
 		goto error;
 	}
 	box->ops = &jp2_boxinfo_unk.ops;
@@ -301,7 +301,6 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)
 	}
 
 	return box;
-	abort();
 
 error:
 	if (box) {
@@ -372,7 +371,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)
 	jp2_bpcc_t *bpcc = &box->data.bpcc;
 	unsigned int i;
 	bpcc->numcmpts = box->datalen;
-	if (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts * sizeof(uint_fast8_t)))) {
+	if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {
 		return -1;
 	}
 	for (i = 0; i < bpcc->numcmpts; ++i) {
@@ -416,7 +415,7 @@ static int jp2_colr_getdata(jp2_box_t *box, jas_stream_t *in)
 		break;
 	case JP2_COLR_ICC:
 		colr->iccplen = box->datalen - 3;
-		if (!(colr->iccp = jas_malloc(colr->iccplen * sizeof(uint_fast8_t)))) {
+		if (!(colr->iccp = jas_alloc2(colr->iccplen, sizeof(uint_fast8_t)))) {
 			return -1;
 		}
 		if (jas_stream_read(in, colr->iccp, colr->iccplen) != colr->iccplen) {
@@ -453,7 +452,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)
 	if (jp2_getuint16(in, &cdef->numchans)) {
 		return -1;
 	}
-	if (!(cdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t)))) {
+	if (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {
 		return -1;
 	}
 	for (channo = 0; channo < cdef->numchans; ++channo) {
@@ -481,7 +480,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));
 
 	if (dataflag) {
-		tmpstream = jas_stream_memopen(0, 0);
+		if (!(tmpstream = jas_stream_memopen(0, 0))) {
+			goto error;
+		}
 		if (box->ops->putdata) {
 			if ((*box->ops->putdata)(box, tmpstream)) {
 				goto error;
@@ -511,7 +512,6 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)
 	}
 
 	return 0;
-	abort();
 
 error:
 
@@ -766,7 +766,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
 	unsigned int i;
 
 	cmap->numchans = (box->datalen) / 4;
-	if (!(cmap->ents = jas_malloc(cmap->numchans * sizeof(jp2_cmapent_t)))) {
+	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
 		return -1;
 	}
 	for (i = 0; i < cmap->numchans; ++i) {
@@ -828,10 +828,10 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)
 		return -1;
 	}
 	lutsize = pclr->numlutents * pclr->numchans;
-	if (!(pclr->lutdata = jas_malloc(lutsize * sizeof(int_fast32_t)))) {
+	if (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {
 		return -1;
 	}
-	if (!(pclr->bpc = jas_malloc(pclr->numchans * sizeof(uint_fast8_t)))) {
+	if (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {
 		return -1;
 	}
 	for (i = 0; i < pclr->numchans; ++i) {
diff --git a/src/libjasper/jp2/jp2_dec.c b/src/libjasper/jp2/jp2_dec.c
index 65772de..70a7cba 100644
--- a/src/libjasper/jp2/jp2_dec.c
+++ b/src/libjasper/jp2/jp2_dec.c
@@ -291,7 +291,10 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 	case JP2_COLR_ICC:
 		iccprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,
 		  dec->colr->data.colr.iccplen);
-		assert(iccprof);
+		if (!iccprof) {
+			jas_eprintf("error: failed to parse ICC profile\n");
+			goto error;
+		}
 		jas_iccprof_gethdr(iccprof, &icchdr);
 		jas_eprintf("ICC Profile CS %08x\n", icchdr.colorspc);
 		jas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));
@@ -336,7 +339,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 	}
 
 	/* Allocate space for the channel-number to component-number LUT. */
-	if (!(dec->chantocmptlut = jas_malloc(dec->numchans * sizeof(uint_fast16_t)))) {
+	if (!(dec->chantocmptlut = jas_alloc2(dec->numchans, sizeof(uint_fast16_t)))) {
 		jas_eprintf("error: no memory\n");
 		goto error;
 	}
@@ -354,7 +357,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 			if (cmapent->map == JP2_CMAP_DIRECT) {
 				dec->chantocmptlut[channo] = channo;
 			} else if (cmapent->map == JP2_CMAP_PALETTE) {
-				lutents = jas_malloc(pclrd->numlutents * sizeof(int_fast32_t));
+				lutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));
 				for (i = 0; i < pclrd->numlutents; ++i) {
 					lutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];
 				}
@@ -386,6 +389,11 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)
 	/* Determine the type of each component. */
 	if (dec->cdef) {
 		for (i = 0; i < dec->numchans; ++i) {
+			/* Is the channel number reasonable? */
+			if (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {
+				jas_eprintf("error: invalid channel number in CDEF box\n");
+				goto error;
+			}
 			jas_image_setcmpttype(dec->image,
 			  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],
 			  jp2_getct(jas_image_clrspc(dec->image),
diff --git a/src/libjasper/jp2/jp2_enc.c b/src/libjasper/jp2/jp2_enc.c
index 9e1e1fc..86ef640 100644
--- a/src/libjasper/jp2/jp2_enc.c
+++ b/src/libjasper/jp2/jp2_enc.c
@@ -191,7 +191,7 @@ int sgnd;
 		}
 		bpcc = &box->data.bpcc;
 		bpcc->numcmpts = jas_image_numcmpts(image);
-		if (!(bpcc->bpcs = jas_malloc(bpcc->numcmpts *
+		if (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,
 		  sizeof(uint_fast8_t)))) {
 			goto error;
 		}
@@ -285,7 +285,7 @@ int sgnd;
 		}
 		cdef = &box->data.cdef;
 		cdef->numchans = jas_image_numcmpts(image);
-		cdef->ents = jas_malloc(cdef->numchans * sizeof(jp2_cdefchan_t));
+		cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));
 		for (i = 0; i < jas_image_numcmpts(image); ++i) {
 			cdefchanent = &cdef->ents[i];
 			cdefchanent->channo = i;
@@ -351,7 +351,6 @@ int sgnd;
 	}
 
 	return 0;
-	abort();
 
 error:
 
diff --git a/src/libjasper/jpc/jpc_cs.c b/src/libjasper/jpc/jpc_cs.c
index f076571..36acd2a 100644
--- a/src/libjasper/jpc/jpc_cs.c
+++ b/src/libjasper/jpc/jpc_cs.c
@@ -502,7 +502,7 @@ static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 	  !siz->tileheight || !siz->numcomps) {
 		return -1;
 	}
-	if (!(siz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t)))) {
+	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
 		return -1;
 	}
 	for (i = 0; i < siz->numcomps; ++i) {
@@ -744,6 +744,10 @@ static int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
 		return -1;
 	}
 	compparms->numrlvls = compparms->numdlvls + 1;
+	if (compparms->numrlvls > JPC_MAXRLVLS) {
+		jpc_cox_destroycompparms(compparms);
+		return -1;
+	}
 	if (prtflag) {
 		for (i = 0; i < compparms->numrlvls; ++i) {
 			if (jpc_getuint8(in, &tmp)) {
@@ -898,11 +902,15 @@ static int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 	int len;
 	len = ms->len;
 	if (cstate->numcomps <= 256) {
-		jpc_getuint8(in, &tmp);
+		if (jpc_getuint8(in, &tmp)) {
+			return -1;
+		}
 		qcc->compno = tmp;
 		--len;
 	} else {
-		jpc_getuint16(in, &qcc->compno);
+		if (jpc_getuint16(in, &qcc->compno)) {
+			return -1;
+		}
 		len -= 2;
 	}
 	if (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {
@@ -919,9 +927,13 @@ static int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *ou
 {
 	jpc_qcc_t *qcc = &ms->parms.qcc;
 	if (cstate->numcomps <= 256) {
-		jpc_putuint8(out, qcc->compno);
+		if (jpc_putuint8(out, qcc->compno)) {
+			return -1;
+		}
 	} else {
-		jpc_putuint16(out, qcc->compno);
+		if (jpc_putuint16(out, qcc->compno)) {
+			return -1;
+		}
 	}
 	if (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {
 		return -1;
@@ -966,7 +978,9 @@ static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,
 	cstate = 0;
 
 	n = 0;
-	jpc_getuint8(in, &tmp);
+	if (jpc_getuint8(in, &tmp)) {
+		return -1;
+	}
 	++n;
 	compparms->qntsty = tmp & 0x1f;
 	compparms->numguard = (tmp >> 5) & 7;
@@ -982,16 +996,23 @@ static int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,
 		compparms->numstepsizes = (len - n) / 2;
 		break;
 	}
-	if (compparms->numstepsizes > 0) {
-		compparms->stepsizes = jas_malloc(compparms->numstepsizes *
+	if (compparms->numstepsizes > 3 * JPC_MAXRLVLS + 1) {
+		jpc_qcx_destroycompparms(compparms);
+                return -1;
+        } else if (compparms->numstepsizes > 0) {
+		compparms->stepsizes = jas_alloc2(compparms->numstepsizes,
 		  sizeof(uint_fast16_t));
 		assert(compparms->stepsizes);
 		for (i = 0; i < compparms->numstepsizes; ++i) {
 			if (compparms->qntsty == JPC_QCX_NOQNT) {
-				jpc_getuint8(in, &tmp);
+				if (jpc_getuint8(in, &tmp)) {
+					return -1;
+				}
 				compparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);
 			} else {
-				jpc_getuint16(in, &compparms->stepsizes[i]);
+				if (jpc_getuint16(in, &compparms->stepsizes[i])) {
+					return -1;
+				}
 			}
 		}
 	} else {
@@ -1015,10 +1036,14 @@ static int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,
 	jpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);
 	for (i = 0; i < compparms->numstepsizes; ++i) {
 		if (compparms->qntsty == JPC_QCX_NOQNT) {
-			jpc_putuint8(out, JPC_QCX_GETEXPN(
-			  compparms->stepsizes[i]) << 3);
+			if (jpc_putuint8(out, JPC_QCX_GETEXPN(
+			  compparms->stepsizes[i]) << 3)) {
+				return -1;
+			}
 		} else {
-			jpc_putuint16(out, compparms->stepsizes[i]);
+			if (jpc_putuint16(out, compparms->stepsizes[i])) {
+				return -1;
+			}
 		}
 	}
 	return 0;
@@ -1091,7 +1116,7 @@ static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 
 	ppm->len = ms->len - 1;
 	if (ppm->len > 0) {
-		if (!(ppm->data = jas_malloc(ppm->len * sizeof(unsigned char)))) {
+		if (!(ppm->data = jas_malloc(ppm->len))) {
 			goto error;
 		}
 		if (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {
@@ -1160,7 +1185,7 @@ static int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 	}
 	ppt->len = ms->len - 1;
 	if (ppt->len > 0) {
-		if (!(ppt->data = jas_malloc(ppt->len * sizeof(unsigned char)))) {
+		if (!(ppt->data = jas_malloc(ppt->len))) {
 			goto error;
 		}
 		if (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {
@@ -1223,7 +1248,7 @@ static int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 	uint_fast8_t tmp;
 	poc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :
 	  (ms->len / 7);
-	if (!(poc->pchgs = jas_malloc(poc->numpchgs * sizeof(jpc_pocpchg_t)))) {
+	if (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {
 		goto error;
 	}
 	for (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,
@@ -1328,7 +1353,7 @@ static int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 	jpc_crgcomp_t *comp;
 	uint_fast16_t compno;
 	crg->numcomps = cstate->numcomps;
-	if (!(crg->comps = jas_malloc(cstate->numcomps * sizeof(uint_fast16_t)))) {
+	if (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(jpc_crgcomp_t)))) {
 		return -1;
 	}
 	for (compno = 0, comp = crg->comps; compno < cstate->numcomps;
@@ -1467,7 +1492,7 @@ static int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in
 	cstate = 0;
 
 	if (ms->len > 0) {
-		if (!(unk->data = jas_malloc(ms->len * sizeof(unsigned char)))) {
+		if (!(unk->data = jas_malloc(ms->len))) {
 			return -1;
 		}
 		if (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {
diff --git a/src/libjasper/jpc/jpc_dec.c b/src/libjasper/jpc/jpc_dec.c
index fa72a0e..1705951 100644
--- a/src/libjasper/jpc/jpc_dec.c
+++ b/src/libjasper/jpc/jpc_dec.c
@@ -449,7 +449,7 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 
 	if (dec->state == JPC_MH) {
 
-		compinfos = jas_malloc(dec->numcomps * sizeof(jas_image_cmptparm_t));
+		compinfos = jas_alloc2(dec->numcomps, sizeof(jas_image_cmptparm_t));
 		assert(compinfos);
 		for (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;
 		  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {
@@ -465,6 +465,7 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 
 		if (!(dec->image = jas_image_create(dec->numcomps, compinfos,
 		  JAS_CLRSPC_UNKNOWN))) {
+			jas_free(compinfos);
 			return -1;
 		}
 		jas_free(compinfos);
@@ -489,7 +490,7 @@ static int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)
 		dec->curtileendoff = 0;
 	}
 
-	if (JAS_CAST(int, sot->tileno) > dec->numtiles) {
+	if (JAS_CAST(int, sot->tileno) >= dec->numtiles) {
 		jas_eprintf("invalid tile number in SOT marker segment\n");
 		return -1;
 	}
@@ -692,7 +693,7 @@ static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 			tile->realmode = 1;
 		}
 		tcomp->numrlvls = ccp->numrlvls;
-		if (!(tcomp->rlvls = jas_malloc(tcomp->numrlvls *
+		if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,
 		  sizeof(jpc_dec_rlvl_t)))) {
 			return -1;
 		}
@@ -764,7 +765,7 @@ rlvl->bands = 0;
 			  rlvl->cbgheightexpn);
 
 			rlvl->numbands = (!rlvlno) ? 1 : 3;
-			if (!(rlvl->bands = jas_malloc(rlvl->numbands *
+			if (!(rlvl->bands = jas_alloc2(rlvl->numbands,
 			  sizeof(jpc_dec_band_t)))) {
 				return -1;
 			}
@@ -797,7 +798,7 @@ rlvl->bands = 0;
 
 				assert(rlvl->numprcs);
 
-				if (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_dec_prc_t)))) {
+				if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_dec_prc_t)))) {
 					return -1;
 				}
 
@@ -834,7 +835,7 @@ rlvl->bands = 0;
 			if (!(prc->numimsbstagtree = jpc_tagtree_create(prc->numhcblks, prc->numvcblks))) {
 				return -1;
 			}
-			if (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_dec_cblk_t)))) {
+			if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_dec_cblk_t)))) {
 				return -1;
 			}
 
@@ -1069,12 +1070,12 @@ static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 	/* Apply an inverse intercomponent transform if necessary. */
 	switch (tile->cp->mctid) {
 	case JPC_MCT_RCT:
-		assert(dec->numcomps == 3);
+		assert(dec->numcomps >= 3);
 		jpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,
 		  tile->tcomps[2].data);
 		break;
 	case JPC_MCT_ICT:
-		assert(dec->numcomps == 3);
+		assert(dec->numcomps >= 3);
 		jpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,
 		  tile->tcomps[2].data);
 		break;
@@ -1181,7 +1182,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 		return -1;
 	}
 
-	if (!(dec->cmpts = jas_malloc(dec->numcomps * sizeof(jpc_dec_cmpt_t)))) {
+	if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {
 		return -1;
 	}
 
@@ -1204,7 +1205,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);
 	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);
 	dec->numtiles = dec->numhtiles * dec->numvtiles;
-	if (!(dec->tiles = jas_malloc(dec->numtiles * sizeof(jpc_dec_tile_t)))) {
+	if (!(dec->tiles = jas_calloc(dec->numtiles, sizeof(jpc_dec_tile_t)))) {
 		return -1;
 	}
 
@@ -1228,7 +1229,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
 		tile->pkthdrstreampos = 0;
 		tile->pptstab = 0;
 		tile->cp = 0;
-		if (!(tile->tcomps = jas_malloc(dec->numcomps *
+		if (!(tile->tcomps = jas_calloc(dec->numcomps,
 		  sizeof(jpc_dec_tcomp_t)))) {
 			return -1;
 		}
@@ -1280,7 +1281,7 @@ static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
 	jpc_coc_t *coc = &ms->parms.coc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, coc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in COC marker segment\n");
 		return -1;
 	}
@@ -1306,7 +1307,7 @@ static int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)
 	jpc_rgn_t *rgn = &ms->parms.rgn;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, rgn->compno) > dec->numcomps) {
+	if (JAS_CAST(int, rgn->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in RGN marker segment\n");
 		return -1;
 	}
@@ -1355,7 +1356,7 @@ static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)
 	jpc_qcc_t *qcc = &ms->parms.qcc;
 	jpc_dec_tile_t *tile;
 
-	if (JAS_CAST(int, qcc->compno) > dec->numcomps) {
+	if (JAS_CAST(int, qcc->compno) >= dec->numcomps) {
 		jas_eprintf("invalid component number in QCC marker segment\n");
 		return -1;
 	}
@@ -1489,11 +1490,12 @@ static jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)
 	cp->numlyrs = 0;
 	cp->mctid = 0;
 	cp->csty = 0;
-	if (!(cp->ccps = jas_malloc(cp->numcomps * sizeof(jpc_dec_ccp_t)))) {
+	if (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {
+		jpc_dec_cp_destroy(cp);
 		return 0;
 	}
 	if (!(cp->pchglist = jpc_pchglist_create())) {
-		jas_free(cp->ccps);
+		jpc_dec_cp_destroy(cp);
 		return 0;
 	}
 	for (compno = 0, ccp = cp->ccps; compno < cp->numcomps;
@@ -2048,7 +2050,7 @@ jpc_streamlist_t *jpc_streamlist_create()
 	}
 	streamlist->numstreams = 0;
 	streamlist->maxstreams = 100;
-	if (!(streamlist->streams = jas_malloc(streamlist->maxstreams *
+	if (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,
 	  sizeof(jas_stream_t *)))) {
 		jas_free(streamlist);
 		return 0;
@@ -2068,8 +2070,8 @@ int jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,
 	/* Grow the array of streams if necessary. */
 	if (streamlist->numstreams >= streamlist->maxstreams) {
 		newmaxstreams = streamlist->maxstreams + 1024;
-		if (!(newstreams = jas_realloc(streamlist->streams,
-		  (newmaxstreams + 1024) * sizeof(jas_stream_t *)))) {
+		if (!(newstreams = jas_realloc2(streamlist->streams,
+		  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {
 			return -1;
 		}
 		for (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {
@@ -2155,8 +2157,7 @@ int jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)
 {
 	jpc_ppxstabent_t **newents;
 	if (tab->maxents < maxents) {
-		newents = (tab->ents) ? jas_realloc(tab->ents, maxents *
-		  sizeof(jpc_ppxstabent_t *)) : jas_malloc(maxents * sizeof(jpc_ppxstabent_t *));
+		newents = jas_realloc2(tab->ents, maxents, sizeof(jpc_ppxstabent_t *));
 		if (!newents) {
 			return -1;
 		}
@@ -2267,7 +2268,9 @@ jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)
 	return streams;
 
 error:
-	jpc_streamlist_destroy(streams);
+	if (streams) {
+		jpc_streamlist_destroy(streams);
+	}
 	return 0;
 }
 
diff --git a/src/libjasper/jpc/jpc_enc.c b/src/libjasper/jpc/jpc_enc.c
index bbe1ef2..ca7cbb7 100644
--- a/src/libjasper/jpc/jpc_enc.c
+++ b/src/libjasper/jpc/jpc_enc.c
@@ -403,7 +403,7 @@ static jpc_enc_cp_t *cp_create(char *optstr, jas_image_t *image)
 		vsteplcm *= jas_image_cmptvstep(image, cmptno);
 	}
 
-	if (!(cp->ccps = jas_malloc(cp->numcmpts * sizeof(jpc_enc_ccp_t)))) {
+	if (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {
 		goto error;
 	}
 	for (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,
@@ -656,7 +656,7 @@ static jpc_enc_cp_t *cp_create(char *optstr, jas_image_t *image)
 
 	if (ilyrrates && numilyrrates > 0) {
 		tcp->numlyrs = numilyrrates + 1;
-		if (!(tcp->ilyrrates = jas_malloc((tcp->numlyrs - 1) *
+		if (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),
 		  sizeof(jpc_fix_t)))) {
 			goto error;
 		}
@@ -781,11 +781,10 @@ void jpc_enc_cp_destroy(jpc_enc_cp_t *cp)
 
 int ratestrtosize(char *s, uint_fast32_t rawsize, uint_fast32_t *size)
 {
-	char *cp;
 	jpc_flt_t f;
 
 	/* Note: This function must not modify output size on failure. */
-	if ((cp = strchr(s, 'B'))) {
+	if (strchr(s, 'B')) {
 		*size = atoi(s);
 	} else {
 		f = atof(s);
@@ -940,7 +939,7 @@ startoff = jas_stream_getrwcount(enc->out);
 	siz->tilewidth = cp->tilewidth;
 	siz->tileheight = cp->tileheight;
 	siz->numcomps = cp->numcmpts;
-	siz->comps = jas_malloc(siz->numcomps * sizeof(jpc_sizcomp_t));
+	siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));
 	assert(siz->comps);
 	for (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {
 		siz->comps[i].prec = cp->ccps[i].prec;
@@ -977,7 +976,7 @@ startoff = jas_stream_getrwcount(enc->out);
 		return -1;
 	}
 	crg = &enc->mrk->parms.crg;
-	crg->comps = jas_malloc(crg->numcomps * sizeof(jpc_crgcomp_t));
+	crg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));
 	if (jpc_putms(enc->out, enc->cstate, enc->mrk)) {
 		jas_eprintf("cannot write CRG marker\n");
 		return -1;
@@ -1955,7 +1954,7 @@ jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int ti
 	tile->mctid = cp->tcp.mctid;
 
 	tile->numlyrs = cp->tcp.numlyrs;
-	if (!(tile->lyrsizes = jas_malloc(tile->numlyrs *
+	if (!(tile->lyrsizes = jas_alloc2(tile->numlyrs,
 	  sizeof(uint_fast32_t)))) {
 		goto error;
 	}
@@ -1964,7 +1963,7 @@ jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int ti
 	}
 
 	/* Allocate an array for the per-tile-component information. */
-	if (!(tile->tcmpts = jas_malloc(cp->numcmpts * sizeof(jpc_enc_tcmpt_t)))) {
+	if (!(tile->tcmpts = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_tcmpt_t)))) {
 		goto error;
 	}
 	/* Initialize a few members critical for error recovery. */
@@ -2102,15 +2101,14 @@ static jpc_enc_tcmpt_t *tcmpt_create(jpc_enc_tcmpt_t *tcmpt, jpc_enc_cp_t *cp,
 
 	tcmpt->numstepsizes = tcmpt->numbands;
 	assert(tcmpt->numstepsizes <= JPC_MAXBANDS);
-	memset(tcmpt->stepsizes, 0, sizeof(tcmpt->numstepsizes *
-	  sizeof(uint_fast16_t)));
+	memset(tcmpt->stepsizes, 0, tcmpt->numstepsizes * sizeof(uint_fast16_t));
 
 	/* Retrieve information about the various bands. */
 	jpc_tsfb_getbands(tcmpt->tsfb, jas_seq2d_xstart(tcmpt->data),
 	  jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data),
 	  jas_seq2d_yend(tcmpt->data), bandinfos);
 
-	if (!(tcmpt->rlvls = jas_malloc(tcmpt->numrlvls * sizeof(jpc_enc_rlvl_t)))) {
+	if (!(tcmpt->rlvls = jas_alloc2(tcmpt->numrlvls, sizeof(jpc_enc_rlvl_t)))) {
 		goto error;
 	}
 	for (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;
@@ -2213,7 +2211,7 @@ static jpc_enc_rlvl_t *rlvl_create(jpc_enc_rlvl_t *rlvl, jpc_enc_cp_t *cp,
 	rlvl->numvprcs = JPC_FLOORDIVPOW2(brprcbry - tlprctly, rlvl->prcheightexpn);
 	rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;
 
-	if (!(rlvl->bands = jas_malloc(rlvl->numbands * sizeof(jpc_enc_band_t)))) {
+	if (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_enc_band_t)))) {
 		goto error;
 	}
 	for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;
@@ -2290,7 +2288,7 @@ if (bandinfo->xstart != bandinfo->xend && bandinfo->ystart != bandinfo->yend) {
 	band->synweight = bandinfo->synenergywt;
 
 if (band->data) {
-	if (!(band->prcs = jas_malloc(rlvl->numprcs * sizeof(jpc_enc_prc_t)))) {
+	if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_enc_prc_t)))) {
 		goto error;
 	}
 	for (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs; ++prcno,
@@ -2422,7 +2420,7 @@ if (!rlvlno) {
 			goto error;
 		}
 
-		if (!(prc->cblks = jas_malloc(prc->numcblks * sizeof(jpc_enc_cblk_t)))) {
+		if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_enc_cblk_t)))) {
 			goto error;
 		}
 		for (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;
diff --git a/src/libjasper/jpc/jpc_mqdec.c b/src/libjasper/jpc/jpc_mqdec.c
index 4cc2f46..66a8581 100644
--- a/src/libjasper/jpc/jpc_mqdec.c
+++ b/src/libjasper/jpc/jpc_mqdec.c
@@ -118,7 +118,7 @@ jpc_mqdec_t *jpc_mqdec_create(int maxctxs, jas_stream_t *in)
 	mqdec->in = in;
 	mqdec->maxctxs = maxctxs;
 	/* Allocate memory for the per-context state information. */
-	if (!(mqdec->ctxs = jas_malloc(mqdec->maxctxs * sizeof(jpc_mqstate_t *)))) {
+	if (!(mqdec->ctxs = jas_alloc2(mqdec->maxctxs, sizeof(jpc_mqstate_t *)))) {
 		goto error;
 	}
 	/* Set the current context to the first context. */
diff --git a/src/libjasper/jpc/jpc_mqenc.c b/src/libjasper/jpc/jpc_mqenc.c
index 758b361..399581e 100644
--- a/src/libjasper/jpc/jpc_mqenc.c
+++ b/src/libjasper/jpc/jpc_mqenc.c
@@ -197,7 +197,7 @@ jpc_mqenc_t *jpc_mqenc_create(int maxctxs, jas_stream_t *out)
 	mqenc->maxctxs = maxctxs;
 
 	/* Allocate memory for the per-context state information. */
-	if (!(mqenc->ctxs = jas_malloc(mqenc->maxctxs * sizeof(jpc_mqstate_t *)))) {
+	if (!(mqenc->ctxs = jas_alloc2(mqenc->maxctxs, sizeof(jpc_mqstate_t *)))) {
 		goto error;
 	}
 
diff --git a/src/libjasper/jpc/jpc_qmfb.c b/src/libjasper/jpc/jpc_qmfb.c
index 00d406d..4fad82d 100644
--- a/src/libjasper/jpc/jpc_qmfb.c
+++ b/src/libjasper/jpc/jpc_qmfb.c
@@ -306,11 +306,7 @@ void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity)
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numcols, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];
-#else
-	jpc_fix_t splitbuf[bufsize];
-#endif
 	jpc_fix_t *buf = splitbuf;
 	register jpc_fix_t *srcptr;
 	register jpc_fix_t *dstptr;
@@ -318,15 +314,13 @@ void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity)
 	register int m;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Get a buffer. */
 	if (bufsize > QMFB_SPLITBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide in this case. */
 			abort();
 		}
 	}
-#endif
 
 	if (numcols >= 2) {
 		hstartcol = (numcols + 1 - parity) >> 1;
@@ -360,12 +354,10 @@ void jpc_qmfb_split_row(jpc_fix_t *a, int numcols, int parity)
 		}
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the split buffer was allocated on the heap, free this memory. */
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -374,11 +366,7 @@ void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];
-#else
-	jpc_fix_t splitbuf[bufsize];
-#endif
 	jpc_fix_t *buf = splitbuf;
 	register jpc_fix_t *srcptr;
 	register jpc_fix_t *dstptr;
@@ -386,15 +374,13 @@ void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,
 	register int m;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Get a buffer. */
 	if (bufsize > QMFB_SPLITBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide in this case. */
 			abort();
 		}
 	}
-#endif
 
 	if (numrows >= 2) {
 		hstartcol = (numrows + 1 - parity) >> 1;
@@ -428,12 +414,10 @@ void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,
 		}
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the split buffer was allocated on the heap, free this memory. */
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -442,11 +426,7 @@ void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];
-#else
-	jpc_fix_t splitbuf[bufsize * JPC_QMFB_COLGRPSIZE];
-#endif
 	jpc_fix_t *buf = splitbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
@@ -457,15 +437,13 @@ void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,
 	int m;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Get a buffer. */
 	if (bufsize > QMFB_SPLITBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide in this case. */
 			abort();
 		}
 	}
-#endif
 
 	if (numrows >= 2) {
 		hstartcol = (numrows + 1 - parity) >> 1;
@@ -517,12 +495,10 @@ void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride,
 		}
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the split buffer was allocated on the heap, free this memory. */
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -531,11 +507,7 @@ void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];
-#else
-	jpc_fix_t splitbuf[bufsize * numcols];
-#endif
 	jpc_fix_t *buf = splitbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
@@ -546,15 +518,13 @@ void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,
 	int m;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Get a buffer. */
 	if (bufsize > QMFB_SPLITBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide in this case. */
 			abort();
 		}
 	}
-#endif
 
 	if (numrows >= 2) {
 		hstartcol = (numrows + 1 - parity) >> 1;
@@ -606,12 +576,10 @@ void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,
 		}
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the split buffer was allocated on the heap, free this memory. */
 	if (buf != splitbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -619,26 +587,20 @@ void jpc_qmfb_join_row(jpc_fix_t *a, int numcols, int parity)
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numcols, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE];
-#else
-	jpc_fix_t joinbuf[bufsize];
-#endif
 	jpc_fix_t *buf = joinbuf;
 	register jpc_fix_t *srcptr;
 	register jpc_fix_t *dstptr;
 	register int n;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Allocate memory for the join buffer from the heap. */
 	if (bufsize > QMFB_JOINBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide. */
 			abort();
 		}
 	}
-#endif
 
 	hstartcol = (numcols + 1 - parity) >> 1;
 
@@ -670,12 +632,10 @@ void jpc_qmfb_join_row(jpc_fix_t *a, int numcols, int parity)
 		++srcptr;
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the join buffer was allocated on the heap, free this memory. */
 	if (buf != joinbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -684,26 +644,20 @@ void jpc_qmfb_join_col(jpc_fix_t *a, int numrows, int stride,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE];
-#else
-	jpc_fix_t joinbuf[bufsize];
-#endif
 	jpc_fix_t *buf = joinbuf;
 	register jpc_fix_t *srcptr;
 	register jpc_fix_t *dstptr;
 	register int n;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Allocate memory for the join buffer from the heap. */
 	if (bufsize > QMFB_JOINBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide. */
 			abort();
 		}
 	}
-#endif
 
 	hstartcol = (numrows + 1 - parity) >> 1;
 
@@ -735,12 +689,10 @@ void jpc_qmfb_join_col(jpc_fix_t *a, int numrows, int stride,
 		++srcptr;
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the join buffer was allocated on the heap, free this memory. */
 	if (buf != joinbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -749,11 +701,7 @@ void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];
-#else
-	jpc_fix_t joinbuf[bufsize * JPC_QMFB_COLGRPSIZE];
-#endif
 	jpc_fix_t *buf = joinbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
@@ -763,15 +711,13 @@ void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,
 	register int i;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Allocate memory for the join buffer from the heap. */
 	if (bufsize > QMFB_JOINBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * JPC_QMFB_COLGRPSIZE * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc2(bufsize, JPC_QMFB_COLGRPSIZE * sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide. */
 			abort();
 		}
 	}
-#endif
 
 	hstartcol = (numrows + 1 - parity) >> 1;
 
@@ -821,12 +767,10 @@ void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,
 		srcptr += JPC_QMFB_COLGRPSIZE;
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the join buffer was allocated on the heap, free this memory. */
 	if (buf != joinbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
@@ -835,11 +779,7 @@ void jpc_qmfb_join_colres(jpc_fix_t *a, int numrows, int numcols,
 {
 
 	int bufsize = JPC_CEILDIVPOW2(numrows, 1);
-#if !defined(HAVE_VLA)
 	jpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];
-#else
-	jpc_fix_t joinbuf[bufsize * numcols];
-#endif
 	jpc_fix_t *buf = joinbuf;
 	jpc_fix_t *srcptr;
 	jpc_fix_t *dstptr;
@@ -849,15 +789,13 @@ void jpc_qmfb_join_colres(jpc_fix_t *a, int numrows, int numcols,
 	register int i;
 	int hstartcol;
 
-#if !defined(HAVE_VLA)
 	/* Allocate memory for the join buffer from the heap. */
 	if (bufsize > QMFB_JOINBUFSIZE) {
-		if (!(buf = jas_malloc(bufsize * numcols * sizeof(jpc_fix_t)))) {
+		if (!(buf = jas_alloc3(bufsize, numcols, sizeof(jpc_fix_t)))) {
 			/* We have no choice but to commit suicide. */
 			abort();
 		}
 	}
-#endif
 
 	hstartcol = (numrows + 1 - parity) >> 1;
 
@@ -907,12 +845,10 @@ void jpc_qmfb_join_colres(jpc_fix_t *a, int numrows, int numcols,
 		srcptr += numcols;
 	}
 
-#if !defined(HAVE_VLA)
 	/* If the join buffer was allocated on the heap, free this memory. */
 	if (buf != joinbuf) {
 		jas_free(buf);
 	}
-#endif
 
 }
 
diff --git a/src/libjasper/jpc/jpc_t1enc.c b/src/libjasper/jpc/jpc_t1enc.c
index 3a5acea..93c96ce 100644
--- a/src/libjasper/jpc/jpc_t1enc.c
+++ b/src/libjasper/jpc/jpc_t1enc.c
@@ -219,12 +219,12 @@ int jpc_enc_enccblk(jpc_enc_t *enc, jas_stream_t *out, jpc_enc_tcmpt_t *tcmpt, j
 
 	cblk->numpasses = (cblk->numbps > 0) ? (3 * cblk->numbps - 2) : 0;
 	if (cblk->numpasses > 0) {
-		cblk->passes = jas_malloc(cblk->numpasses * sizeof(jpc_enc_pass_t));
+		cblk->passes = jas_alloc2(cblk->numpasses, sizeof(jpc_enc_pass_t));
 		assert(cblk->passes);
 	} else {
 		cblk->passes = 0;
 	}
-	endpasses = &cblk->passes[cblk->numpasses];
+	endpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;
 	for (pass = cblk->passes; pass != endpasses; ++pass) {
 		pass->start = 0;
 		pass->end = 0;
@@ -352,7 +352,7 @@ dump_passes(cblk->passes, cblk->numpasses, cblk);
 #endif
 
 	n = 0;
-	endpasses = &cblk->passes[cblk->numpasses];
+	endpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;
 	for (pass = cblk->passes; pass != endpasses; ++pass) {
 		if (pass->start < n) {
 			pass->start = n;
diff --git a/src/libjasper/jpc/jpc_t2cod.c b/src/libjasper/jpc/jpc_t2cod.c
index e734900..da28de5 100644
--- a/src/libjasper/jpc/jpc_t2cod.c
+++ b/src/libjasper/jpc/jpc_t2cod.c
@@ -429,7 +429,7 @@ static int jpc_pi_nextcprl(register jpc_pi_t *pi)
 	}
 
 	for (pi->compno = pchg->compnostart, pi->picomp =
-	  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,
+	  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,
 	  ++pi->picomp) {
 		pirlvl = pi->picomp->pirlvls;
 		pi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +
@@ -573,7 +573,7 @@ int jpc_pchglist_insert(jpc_pchglist_t *pchglist, int pchgno, jpc_pchg_t *pchg)
 	}
 	if (pchglist->numpchgs >= pchglist->maxpchgs) {
 		newmaxpchgs = pchglist->maxpchgs + 128;
-		if (!(newpchgs = jas_realloc(pchglist->pchgs, newmaxpchgs * sizeof(jpc_pchg_t *)))) {
+		if (!(newpchgs = jas_realloc2(pchglist->pchgs, newmaxpchgs, sizeof(jpc_pchg_t *)))) {
 			return -1;
 		}
 		pchglist->maxpchgs = newmaxpchgs;
diff --git a/src/libjasper/jpc/jpc_t2dec.c b/src/libjasper/jpc/jpc_t2dec.c
index 6d2cb72..8300f9b 100644
--- a/src/libjasper/jpc/jpc_t2dec.c
+++ b/src/libjasper/jpc/jpc_t2dec.c
@@ -478,7 +478,7 @@ jpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 		return 0;
 	}
 	pi->numcomps = dec->numcomps;
-	if (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {
+	if (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {
 		jpc_pi_destroy(pi);
 		return 0;
 	}
@@ -490,7 +490,7 @@ jpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 	for (compno = 0, tcomp = tile->tcomps, picomp = pi->picomps;
 	  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {
 		picomp->numrlvls = tcomp->numrlvls;
-		if (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *
+		if (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,
 		  sizeof(jpc_pirlvl_t)))) {
 			jpc_pi_destroy(pi);
 			return 0;
@@ -503,7 +503,7 @@ jpc_pi_t *jpc_dec_pi_create(jpc_dec_t *dec, jpc_dec_tile_t *tile)
 		  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {
 /* XXX sizeof(long) should be sizeof different type */
 			pirlvl->numprcs = rlvl->numprcs;
-			if (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *
+			if (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,
 			  sizeof(long)))) {
 				jpc_pi_destroy(pi);
 				return 0;
diff --git a/src/libjasper/jpc/jpc_t2enc.c b/src/libjasper/jpc/jpc_t2enc.c
index 9358a1c..d0c5fd1 100644
--- a/src/libjasper/jpc/jpc_t2enc.c
+++ b/src/libjasper/jpc/jpc_t2enc.c
@@ -335,7 +335,9 @@ assert(jpc_firstone(datalen) < cblk->numlenbits + jpc_floorlog2(passcount));
 		if (!(ms = jpc_ms_create(JPC_MS_EPH))) {
 			return -1;
 		}
-		jpc_putms(out, enc->cstate, ms);
+		if (jpc_putms(out, enc->cstate, ms)) {
+			return -1;
+		}
 		jpc_ms_destroy(ms);
 	}
 
@@ -565,7 +567,7 @@ jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile)
 	}
 	pi->pktno = -1;
 	pi->numcomps = cp->numcmpts;
-	if (!(pi->picomps = jas_malloc(pi->numcomps * sizeof(jpc_picomp_t)))) {
+	if (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {
 		jpc_pi_destroy(pi);
 		return 0;
 	}
@@ -577,7 +579,7 @@ jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile)
 	for (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;
 	  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {
 		picomp->numrlvls = tcomp->numrlvls;
-		if (!(picomp->pirlvls = jas_malloc(picomp->numrlvls *
+		if (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,
 		  sizeof(jpc_pirlvl_t)))) {
 			jpc_pi_destroy(pi);
 			return 0;
@@ -591,7 +593,7 @@ jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile)
 /* XXX sizeof(long) should be sizeof different type */
 			pirlvl->numprcs = rlvl->numprcs;
 			if (rlvl->numprcs) {
-				if (!(pirlvl->prclyrnos = jas_malloc(pirlvl->numprcs *
+				if (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,
 				  sizeof(long)))) {
 					jpc_pi_destroy(pi);
 					return 0;
diff --git a/src/libjasper/jpc/jpc_tagtree.c b/src/libjasper/jpc/jpc_tagtree.c
index 06422d3..1194e7f 100644
--- a/src/libjasper/jpc/jpc_tagtree.c
+++ b/src/libjasper/jpc/jpc_tagtree.c
@@ -125,7 +125,8 @@ jpc_tagtree_t *jpc_tagtree_create(int numleafsh, int numleafsv)
 		++numlvls;
 	} while (n > 1);
 
-	if (!(tree->nodes_ = jas_malloc(tree->numnodes_ * sizeof(jpc_tagtreenode_t)))) {
+	if (!(tree->nodes_ = jas_alloc2(tree->numnodes_, sizeof(jpc_tagtreenode_t)))) {
+		jpc_tagtree_destroy(tree);
 		return 0;
 	}
 
diff --git a/src/libjasper/jpc/jpc_util.c b/src/libjasper/jpc/jpc_util.c
index f53e248..6da1b66 100644
--- a/src/libjasper/jpc/jpc_util.c
+++ b/src/libjasper/jpc/jpc_util.c
@@ -109,7 +109,7 @@ int jpc_atoaf(char *s, int *numvalues, double **values)
 	}
 
 	if (n) {
-		if (!(vs = jas_malloc(n * sizeof(double)))) {
+		if (!(vs = jas_alloc2(n, sizeof(double)))) {
 			return -1;
 		}
 
diff --git a/src/libjasper/mif/mif_cod.c b/src/libjasper/mif/mif_cod.c
index 17506a1..cb62200 100644
--- a/src/libjasper/mif/mif_cod.c
+++ b/src/libjasper/mif/mif_cod.c
@@ -438,8 +438,7 @@ static int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)
 	int cmptno;
 	mif_cmpt_t **newcmpts;
 	assert(maxcmpts >= hdr->numcmpts);
-	newcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :
-	  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));
+	newcmpts = jas_realloc2(hdr->cmpts, maxcmpts, sizeof(mif_cmpt_t *));
 	if (!newcmpts) {
 		return -1;
 	}
@@ -565,7 +564,7 @@ static int mif_process_cmpt(mif_hdr_t *hdr, char *buf)
 			break;
 		case MIF_DATA:
 			if (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {
-				return -1;
+				goto error;
 			}
 			break;
 		}
diff --git a/src/libjasper/ras/ras_enc.c b/src/libjasper/ras/ras_enc.c
index 21e7fcb..075bc0b 100644
--- a/src/libjasper/ras/ras_enc.c
+++ b/src/libjasper/ras/ras_enc.c
@@ -242,8 +242,10 @@ static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image,
 
 	for (y = 0; y < hdr->height; y++) {
 		for (i = 0; i < numcmpts; ++i) {
-			jas_image_readcmpt(image, cmpts[i], 0, y, jas_image_width(image),
-			  1, data[i]);
+			if (jas_image_readcmpt(image, cmpts[i], 0, y,
+					jas_image_width(image), 1, data[i])) {
+				return -1;
+			}
 		}
 		z = 0;
 		nz = 0;
